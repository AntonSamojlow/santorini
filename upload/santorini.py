from random import randint, choice
from sys import stdout
from time import time

class State:
    """class State: Provides tools to check, display and save/export a Santorini gamestate.
The built-in __eq__() is rewritten (ignore ordering of units from same player).
Instance variables:   
  - board:  A 5x5-tuple with integer values between 0 and 4.
  - units:  A dictionary {(i,j) : bool}, the entry is True iff owner is the active player.      
Methods (described in their own docstring):              
  atRandom, from_string(string), string, equiv_class, repr, print(file=None),  
Written by Anton Samojlow, October 2018
"""
    #--- constructor and class methods ----------------------------------------
    def __init__(self, board=((0,)*5,)*5, units={}):
        self.board = board
        self.units = units
    
    @classmethod
    def atRandom(self, turn=None, board_dim=5, units_per_player=2):
        """Returns a random state. Optionally: At a given turn(filling)."""
        units={}
        for rep in range(0,2*units_per_player):
            while True: 
                i, j = randint(0,board_dim-1), randint(0,board_dim-1)
                if (i,j) not in units.keys(): break
            if rep < units_per_player: units[(i,j)] = True
            else: units[(i,j)] = False
        
        maxTurns = 1+4*(board_dim*board_dim-units_per_player)
        if turn == None or turn > maxTurns:
            board = tuple(tuple(randint(0, 2) if (r,c) in units.keys() else randint(0, 4)\
                                for c in range(0, board_dim)) for r in range(0, board_dim))
        else:
            filling = 0
            bh = [[0 for c in range(0, board_dim)] for r in range(0, board_dim)]   
            while filling < turn:
                (r, c) = (randint(0,board_dim-1), randint(0,board_dim-1))  
                if bh[r][c] < 4 - 2*int((r, c) in units.keys()):                    
                    bh[r][c] += 1
                    filling += 1        
            board = tuple( tuple(bh[r][c] for c in range(0,board_dim)) for r in range(0,board_dim))
        return State(board=board, units=units)
    
    @classmethod
    def from_string(self, string, board_dim=5):
        """Returns the state from a string generated by state.strting()."""    
        b = string[:board_dim*board_dim]
        u = string[board_dim*board_dim:]
        
        units = {}
        units_per_player = int(u.__len__()/2)        
        for j in range(0, 2*units_per_player, 2): 
            units[(int(u[0 + j]), int(u[1 + j]))] = bool(j<units_per_player)
        board = tuple(tuple(int(b[r*board_dim + c]) for c in range(0, board_dim))
                      for r in range(0, board_dim))
        return State(board=board, units=units)

    #--- methods --------------------------------------------------------------
    def string(self):
        """Returns 'board'+'units_player'+'units_opponent' with ordered unit positions."""
        string = ''        
        for r in range(0, self.board.__len__()):
            for c in range(0, self.board[r].__len__()): 
                string += str(self.board[r][c])
        
        units_player = sorted([pos for pos in self.units.keys() if self.units[pos]], \
                                                    key=lambda pos: (pos[0], pos[1]))
        units_opponent = sorted([pos for pos in self.units.keys() if not self.units[pos]],\
                                                    key=lambda pos: (pos[0], pos[1]))
        for pos in units_player: string += str(pos[0])+str(pos[1])    
        for pos in units_opponent: string += str(pos[0])+str(pos[1])
        return string 

    def __eq__(self, other):
        """Overriding default: Returns true iff the fields entries agree irresp of the ordering of 'units'."""
        return self.string() == other.string()

    def equiv_class(self):
        """Lists all symmetrically equivalent states for a SQUARE board. [!] Can (rarely) contain duplicates."""
        def H(p): return (self.board.__len__() -1 -p[0], p[1])
        def D(p): return (p[1], p[0])
        symTrafos = [D, lambda p: H(D(p)), lambda p: D(H(D(p))), lambda p: H(D(H(D(p)))),
                     H, lambda p: D(H(p)), lambda p: H(D(H(p))), lambda p: p]

        def transformBy(trafo, s=self):
            new_board = [[0 for c in range(0,s.board[0].__len__())] for r in range(0,s.board.__len__())]
            for r in range(0,s.board.__len__()):
                for c in range(0,s.board[0].__len__()):
                    new_board[trafo((r,c))[0]][trafo((r,c))[1]] = s.board[r][c] 
            new_board = tuple( tuple(r) for r in new_board)
            new_units = {trafo(unitPos) : s.units[unitPos] for unitPos in s.units.keys()}
            return State(board=new_board, units=new_units)        
        return [transformBy(trafo) for trafo in symTrafos]

    def repr(self):
        """Returns the self.string() from equivClass which is lowest wrt alphabetical order."""
        return sorted([s.string() for s in self.equiv_class()])[0]

    def print(self, file=None, playerInitials={ True: 'P' , False: 'O'}):
        """Outputs a representation of the state to sys.stdout, or optionally to 'file'."""
        board_dim = self.board.__len__()

        out = open(file, 'a', encoding='utf-8', newline=None ) if file else stdout        
        for i in range(0, int(3*board_dim/2)): out.write('-')
        out.write(playerInitials[True])
        for i in range(0, int(1/2+ 3*board_dim/2)-1): out.write('-')
        out.write('\n')
        for r in range(0, board_dim):
            for c in range(0, board_dim):
                if (r,c) in self.units.keys():                     
                    out.write(playerInitials[self.units[(r,c)]])
                else: out.write(' ')
                out.write(str(self.board[r][c])+' ')                                    
            out.write('\n')
        for i in range(0,3*board_dim): out.write('-')
        out.write('\n')

        if out is not stdout:
            out.close()    
    
class Environment:
    """class Environment, holds meta-information, like
Instance variables:
  - board_dim
  - units_per_player
  - neighbours      A dictionary {(i,j) : [(i,j),...]}, for lookup of neighbor positions.    
Methods (described in their own docstring):              
  get_moves(state), do_move(move, state), get_plays(state), do_play(play, state),
  exists_winIn(k, state), exists_loseIn(l, state), score(state), heuristic_value(state)
Written by Anton Samojlow, October 2018
"""
    #--- constructor and class methods ----------------------------------------
    def __init__(self, board_dim=5, units_per_player=2):        
        self.board_dim = board_dim
        self.units_per_player = units_per_player

        self.neighbours = {}
        for r in range(0, board_dim):
            for c in range(0, board_dim):
                neighbours =  [(r+x, c+y) for x in [-1,0,1] for y in [-1,0,1] 
                    if r+x >= 0 and r+x < board_dim and c+y >= 0 and c+y < board_dim 
                    and (x != 0 or y != 0)]
                self.neighbours.update({(r,c) : neighbours})
    
    def get_moves(self, state):
        """Return a list of moves '(unitToMove, destination)'."""
        moves = []
        for unitPos in [p for p in list(state.units.keys()) if state.units[p]]:
            for dest in self.neighbours[unitPos]:
                if state.board[dest[0]][dest[1]] <= 3\
                        and not dest in list(state.units.keys())\
                        and state.board[dest[0]][dest[1]]-state.board[unitPos[0]][unitPos[1]] <= 1:
                    moves.append((unitPos,dest))
        return moves

    def do_move(self, move, state):
        """Returns a new state after executing the move. Active player is not changed."""
        (unitPos, dest) = move 
        new_units = {pos : state.units[pos] for pos in state.units.keys() if pos != unitPos}
        new_units[dest] = True
        return State(board=state.board, units=new_units)
                    
    def get_plays(self, state):
        """Return a list of plays '(unitToMove, destination, buildPos)'."""
        plays = []
        moves = self.get_moves(state)        
        for move in moves:
            plays.append((move[0],move[1],move[0]))
            for buildPos in self.neighbours[move[1]]:            
                if state.board[buildPos[0]][buildPos[1]] != 4\
                        and buildPos not in list(state.units.keys()):
                    plays.append((move[0],move[1],buildPos))
        return plays
    
    def do_play(self, play, state):
        """Returns a new state after executing the play. Active player is changed."""
        (unitPos, dest, build) = play
        new_units = {pos : not state.units[pos] for pos in state.units.keys() if pos != unitPos}
        new_units[dest] = False
        new_board = tuple(tuple((state.board[r][c]+1 if (r, c) == (build[0], build[1]) \
                                                                    else state.board[r][c]) \
                                      for c in range(0, self.board_dim)) 
                                for r in range(0, self.board_dim))
        return State(board=new_board, units=new_units) 

    def exists_winIn(self, k, state):     
        """Returns true iff active player has a (up to) k-turn winning strategy. Searchdepth: 2k-1:"""
        if k<=0: return False       
        
        Moves = self.get_moves(state)
        if Moves.__len__() == 0: return False        
    
        for m in [self.do_move(M, state) for M in Moves]:
            if 3 in [m.board[pos[0]][pos[1]] for pos in m.units.keys()]: return True
                
        for play in [self.do_play(P, state) for P in self.get_plays(state)]:                    
            if self.exists_loseIn(k-1, state): return True
        
        return False

    def exists_loseIn(self, k, state):
        """Returns true iff for any play, the opponent has a k-turn winning strategy. Searchdepth: 2k"""
        # assuming k >= 0
        Moves = self.get_moves(state)
        if Moves.__len__() == 0: return True
        if k > 0:
            for m in [self.do_move(M, state) for M in Moves]:
                if 3 in [m.board[pos[0]][pos[1]] for pos in m.units.keys()]: return False

            for play in [self.do_play(P, state) for P in self.get_plays(state)]:      
                if not self.exists_winIn(k, state): return False
            return True
        
        return False

    def score(self, state):
        """Returns +1/-1 if active player won/lost, 0 else. [!] Inconsistent if two or more units are on level 3."""        
        for pos in state.units.keys():
            if state.board[pos[0]][pos[1]] == 3: return -1+2*int(state.units[pos])               
        if self.get_moves(state).__len__() == 0: return -1
        return 0   

    def heuristic_value(self, state):
        """Returns a heuristic value of the gamestate, from the perspective of the active(!) player."""
        # Check if a player has a won. 
        #     Does not [!] check for the non-valid situation of two units on level 3      
        score = self.score(state)    
        if score != 0: return score

        # Compute some indicators 
        Moves = self.get_moves(state)
        turnNr = sum( [ sum(state.board[i]) for i in range(0, self.board_dim)] ) # max: 93

        units_player = [pos for pos in state.units.keys() if state.units[pos]]
        units_opponent = [pos for pos in state.units.keys() if not state.units[pos]]

        # (1)   number of possible moves (min: 0, max: 16)
        I1 = 1/16*Moves.__len__()
        a1 = 1/3*(1/50*turnNr if turnNr <= 50 else 1)

        # (2)   summed heightscore of possible moves (min: 0, max: 3*number of moves => WIN)
        I2 = 0
        for m in [self.do_move(M, state) for M in Moves]:
            I2 += sum([int(m.units[pos])*m.board[pos[0]][pos[1]] \
                                        for pos in list(m.units.keys())])
        I2 = I2/(3*Moves.__len__())
        a2 = 1/3

        # (3)   number of adjacent opponents units that are not higher (min: 0, max: 2)
        I3 = 0
        for o in units_opponent: 
            for p in units_player: 
                if p in self.neighbours[o] and state.board[p[0]][p[1]] >= state.board[o[0]][o[1]] : 
                    I3 += 1/2
                    break
        a3 = 1/3
        return a1*I1 + a2*I2 + a3*I3 


class Player:
    """class player: Blueprint for a Player. 
Use inheritance to define an AI or interface for human play.
Written by Anton Samojlow, October 2018
"""
    def __init__(self, environment, info='random play'):     
        self.info = info
        self.env = environment

    def choose_play(self, state):
        return choice(self.env.get_plays(state))
        
    def choose_unit_pos(self, units):
        while True:
            unitPos = (randint(0, self.env.board_dim-1), randint(0, self.env.board_dim-1))
            if unitPos not in units.keys(): break
        return unitPos

    
class humanConsole(Player):
    """class human(player): A human that plays via the console."""
    def __init__(self, environment, info='human'):     
        self.info = info
        self.env = environment

    def choose_unit_pos(self, units):
        """Asks to input a unit position'."""
        print('Choose a starting position for a unit...')
        freePos = [(i,j) for i in range(0,self.env.board_dim) 
                         for j in range(0,self.env.board_dim) 
                         if (i,j) not in units.keys()]
        return self.inputCoord(freePos)

    def choose_play(self, state):
        """Asks to input a valid play for the active player and returns it as '(unit, dest, build)'."""
        unitPos, dest, build = None, None, None

        validPlays = self.env.get_plays(state)
        print(set(validPlays))
        unitPositions = list({u for (u, d, b) in validPlays})
        print('Choose a unit to move from', unitPositions, '...')
        unitPos = self.inputCoord(unitPositions)
        
        destinations = list({d for (u, d, b) in validPlays if u == unitPos})
        print('Choose a destination from', destinations, '...')
        dest = self.inputCoord(destinations)
            
        buildPositions = [b for (u, d, b) in validPlays if u == unitPos and d == dest]
        print('Choose where to build from', buildPositions, '...')
        build = self.inputCoord(buildPositions)
        return (unitPos, dest, build)

    def inputCoord(self, validList):        
        """Asks to input a coordinate from 'validList'."""
        error = "[!] Valid coordinates are 'xy' with x=row, y=column being integers in [0,4].\
                \nTry again..."

        while True:
            try:
                rawIn = input()
                if rawIn == 'exit': exit()                
                x, y = int(rawIn[0]), int(rawIn[1])
            except IndexError:
                print(error)
                continue
            except ValueError:
                print(error)
                continue
            if rawIn.__len__() != 2:
                print(error)         
            elif (x,y) not in validList:
                print((x,y), 'is not from', validList,'\nTry again...')
            else:
                return (x,y)


class Game:
    """class game: Each instance represents a played game between two instances of 
the class Players. It is played when calling __init__((firstplayer, secondplayer)).
Instance variables:
  - environemnt:      Knows the boardsize and units_per_player
  - startState:       The starting state AFTER the units have been positioned
  - players:          Tuple (firstplayer, secondplayer). Note the first player has index 0, the second index 1
  - plays:            List of plays (unit, dest, build) made
  - result            Equals 1 (2) if the first (second) player has won.
  - playtime          Time it tool to compute the plays
Methods (described in their own docstring):              
  save(file)
Written by Anton Samojlow, October 2018
"""
    #--- constructor and class methods ----------------------------------------
    def __init__(self, players, board_dim=5, units_per_player=2, startState=None, verbose=False):        
        self.env = Environment(board_dim=board_dim, units_per_player=units_per_player)
        self.startState = startState if startState is not None\
                                     else State(board=((0,)*board_dim,)*board_dim)       
        self.players = players   
        self.plays = []
        self.result = 0     
        self.playtime = 0


        if(verbose): 
            print('* start of game')
            print('* first player:', self.players[0].info)
            print('* second player:', self.players[1].info)

        if self.startState.units.__len__() == 0:
            unitDic = {}          
            for i in range(0, self.env.units_per_player):
                for playerNr in range(0, 2):
                    unitPos = self.players[playerNr].choose_unit_pos(unitDic)
                    unitDic[unitPos] = not bool(playerNr)         
            self.startState.units = unitDic

        currentstate = self.startState        
        if(verbose): currentstate.print(playerInitials={True:'A', False:'B'})

        activeplayer = self.players[0]
        t0 = time()
        while True:
            play = activeplayer.choose_play(currentstate)
            self.plays.append(play)
            currentstate =  self.env.do_play(play, currentstate)
            
            activeplayer = self.players[int(not bool(self.players.index(activeplayer)))]
            if(verbose): currentstate.print(playerInitials={activeplayer == self.players[0]:'A', \
                                                                         not activeplayer == self.players[0]:'B'})
            

            v = self.env.score(currentstate)
            if v == -1 or v == 1:
                self.result = 1 + int(bool(self.players.index(activeplayer)) == bool((1+v)/2))
                if(verbose): print('* Player', self.result, 'won!')
                self.playtime = round(time()-t0,3)
                break

    #--- methods --------------------------------------------------------------   

    def save(self, file, format='text'):
        """Appends the game information to a file."""
        if format == 'text':
            with open(file, 'a', newline = None) as f:
                f.write('\n')
                f.write('1st player:  '+self.players[0].info+'\n')
                f.write('2nd player:  '+self.players[1].info+'\n')
                f.write('winner:      '+str(self.result)+'\n')
                f.write('start state: '+self.startState.string()+'\n')
                strPlays = ''.join(str(P) for P in self.plays ).replace(')(','|')
                strPlays =  strPlays.replace(',','').replace(')','').replace('(','').replace(' ','')
                f.write('plays:       '+strPlays+'\n')
                f.write('playtime:    '+str(self.playtime)+' s\n')
                


